---
layout: post
title:  "Weeks 1 to 2"
date:   2018-05-26 14:10:51 +0800
categories: GSoC
tags: GSoC
description: MAY-14-2018 to MAY-26-2018.
---
# Tasks completed in weeks 1 to 2

1. Approximation algorithms and greedy heuristics for the following problems:
  * Travelling Salesman
  * Minimum Vertex cover
  * Minimum Steiner tree
  * Minimum Maximal Matching
  * Greedy coloring with interchange
  * Independent vertex set
  * Dominating vertex set
  * Local node connectivity
2. Implemented Johnson's Shortest Path Algorithm.
3. Improved Run-time of Kruskal's Minimum Spanning Tree.
4. Created the Union-Find data structure. 

# Details

### Approximation algorithms and Greedy Hueristics
I implemented several straight forward approximation algorithms and greedy hueristics.
I deviated from the proposal in the solution to Travelling Salesman because [Christofides](https://en.wikipedia.org/wiki/Christofides_algorithm) algorithm would require linear program solvers and LightGraphs.jl has a policy of minimising dependencies.
A common problem I faced while implementing the algorithms is when using a distributed for loop, the output would be type instable.

### Johnson's Shortest Path Algorithm
Implemented [Johnson's Shortest Path Algorithm](https://en.wikipedia.org/wiki/Johnson%27s_algorithm).
This algorithms invloves applying a transform to the edge weights and then applying Dijkstra. 
I initially forgot to consider the case where the edge weights are immutable. An additional |E| overhead will have to be incurred in that case.

### Kruskal's Minimum Spanning Tree
In this algorithm, we iterate over the edges of a graph in the ascending order of weights until a spanning tree is formed.
I replaced the priority queue being used obtain the edge of smallest weight with a sorting function. I also avoided creating a struct to store the edge and weight by using [sortperm](https://docs.julialang.org/en/stable/stdlib/sort/) so I could first sort the weights and then permute the edges.
For a complete graph with 1,000 vertices, improved run-time from 193 ms to 28 ms.
For a path graph with 10,000 vertices, improved run-time from 3.88 ms to 1.15 ms.

### Union Find Data Structure
This data structure is already available in DataStructures.jl. I coded a version of it that would be optimised for graph algorithms
that involve iteratively adding edges to the graph. However, there was only a minor improvement in performance when I coded Kruskal's MST using my data structure. So maintaining this code in LightGraphs may not be worth it when the data structure is available in a standard library.
For a complete graph with 1,000 vertices, improved run-time from 28 ms to 26 ms.

# Lessons Learned
I lost 2 days of code while using git. Commit each file as soon as its coded.
